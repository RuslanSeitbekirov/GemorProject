Пользователь обращается к системе через Telegram в первый раз или после выхода (неизвестный пользователь)
Пользователь через приложение Telegram отправляет сообщение (любое) на сервера Telegram;
Компонент Telegram Client обращается к серверам Telegram и получает список всех новых сообщений;
Компонент Telegram Client достаёт из списка новых сообщений наше (предполагается, что оно первое в списке) затем обрабатываются остальные;
Компонент Telegram Client проверяет сообщение пользователя на предусмотренное в боте.
Если мы не предусмотрели ответ на такое сообщение, то отвечаем:
Нет такой команды;
Если обработчик для сообщения пользователя найден, то Telegram Client перенаправляет запрос компоненту Bot Logic (перед ним сидит компонент Nginx);
Nginx перенаправляет запрос одной из рабочих копий компонента Bot Logic;
Bot Logic делает запрос к компоненту Redis используя chat_id в качестве ключа. chat_id присылается сервером Telegram вместе с сообщением пользователя. Он всегда одинаковый для пары пользователь-бот и позволяет однозначно идентифицировать пользователя;
Redis сообщает, что такого ключа нет;
Если обработчик login без параметров или любой другой:
Bot Logic формирует ответ сообщающий, что пользователь не заголинен и предлагающий пользователю авторизоваться через: GitHub, Яндекс ID или через код; Ответ уходит пользователю.
Если обработчик login с параметром type:
Генерируем новый токен входа;
Делаем запрос Redis чтобы он запомнил текущий chat_id как ключ, а в качестве значения: статус пользователя: Анонимный и токен входа;
Bot Logic делает запрос к модулю Авторизации (указывая токен входа);
Ждём ответа от модуль Авторизации и перенаправляем его пользователю.
Пользователь обращается к системе через Telegram (имея статус Анонимный)
Пользователь через приложение Telegram отправляет сообщение (любое) на сервера Telegram;
Компонент Telegram Client обращается к серверам Telegram и получает список всех новых сообщений;
Компонент Telegram Client достаёт из списка новых сообщений наше (предполагается, что оно первое в списке) затем обрабатываются остальные;
Компонент Telegram Client проверяет сообщение пользователя на предусмотренное в боте.
Если мы не предусмотрели ответ на такое сообщение, то отвечаем:
Нет такой команды;
Если обработчик для сообщения пользователя найден, то Telegram Client перенаправляет запрос компоненту Bot Logic (перед ним сидит компонент Nginx);
Nginx перенаправляет запрос одной из рабочих копий компонента Bot Logic;
Bot Logic делает запрос к компоненту Redis используя chat_id в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя;
Redis сообщает, что такой ключ есть и присылает данные соответствующие ключу;
Bot Logic достаёт из ответа статус пользователя. Он равен: Анонимный;
Если обработчик login с параметром type:
Генерируем новый токен входа;
Делаем запрос Redis чтобы он заменил текущий токен входа на новый для ключа chat_id;
Bot Logic делает запрос к модулю Авторизации (указывая токен входа);
Ждём ответа от модуль Авторизации и перенаправляем его пользователю.
Если обработчик login без параметров или любой другой:
Bot Logic достаёт из ответа от Redis токен входа и делает запрос модулю Авторизации отправляя токен входа для проверки;
Модуль Авторизации проверяет есть ли у него запись для указанного токена входа и отвечает;
Если ответ от модуля Авторизации: не опознанный токен или время действия токена закончилось:
Bot Logic делает запрос Redis, чтобы тот удалил ключ chat_id. Пользователь переходит в статус Неизвестный;
Bot Logic формирует ответ сообщающий, что пользователь не заголинен и предлагающий пользователю авторизоваться через: GitHub, Яндекс ID или через код; Ответ уходит пользователю.
Если ответ от модуля Авторизации: в доступе отказано (пользователь нажал Нет во время входа):
Bot Logic делает запрос Redis, чтобы тот удалил ключ chat_id. Пользователь переходит в статус Неизвестный;
Bot Logic формирует ответ сообщающий: неудачная авторизация; Ответ уходит пользователю;
Если ответ от модуля Авторизации: доступ предоставлен (пользователь нажал Да во время входа), то:
Bot Logic проверяет, что в ответе от модуля авторизации присутствуют 2 JWT токена: токен доступа (Access Token) и токен обновления (Refresh Token);
Они присутствуют. Bot Logic меняет статус пользователя на Авторизованный и делает запрос Redis сохранить новый статус пользователя и оба JWT токена (токен входа больше не нужен). В качестве ключа используется chat_id;
Bot Logic продолжает обрабатывать текущий запрос пользователя так, как будто бы пользователь сразу был в статусе Авторизованный.
Пользователь обращается к системе через Telegram (имея статус Авторизованный)
Пользователь через приложение Telegram отправляет сообщение (любое) на сервера Telegram;
Компонент Telegram Client обращается к серверам Telegram и получает список всех новых сообщений;
Компонент Telegram Client достаёт из списка новых сообщений наше (предполагается, что оно первое в списке) затем обрабатываются остальные;
Компонент Telegram Client проверяет сообщение пользователя на предусмотренное в боте.
Если мы не предусмотрели ответ на такое сообщение, то отвечаем:
Нет такой команды;
Если обработчик для сообщения пользователя найден, то Telegram Client перенаправляет запрос компоненту Bot Logic (перед ним сидит компонент Nginx);
Nginx перенаправляет запрос одной из рабочих копий компонента Bot Logic;
Bot Logic делает запрос к компоненту Redis используя chat_id в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя;
Redis сообщает, что такой ключ есть и присылает данные соответствующие ключу;
Bot Logic достаёт из ответа статус пользователя. Он равен: Авторизованный;
Если обработчик login не важно с параметром type или без, то Bot Logic формирует ответ сообщающий: вы уже авторизованы; Ответ уходит пользователю;
Если обработчик logout без параметров (выйти из системы на этом устройстве):
Bot Logic делает запрос к компоненту Redis и просит удалить ключ. В качестве ключа используется chat_id. Пользователь переходит в статус Неизвестный.
Вot Logic формирует ответ сообщающий: сеанс завершён; Ответ уходит пользователю;
Если обработчик logout с параметром all=true (выйти из системы на всех устройствах):
Bot Logic делает запрос к компоненту Redis и просит удалить ключ. В качестве ключа используется chat_id. Пользователь переходит в статус Неизвестный.
Bot Logic делает запрос к модулю Авторизации на /logout и отправляет ему токен обновления;
Вot Logic формирует ответ сообщающий: сеанс завершён на всех устройствах; Ответ уходит пользователю;
Если обработчик другой (самостоятельно назначить для каждого действия которое можно выполнить в системе):
Вot Logic делает соответствующий запрос к Главному модулю передавая токен доступа в заголовках запроса;
Если токен доступа не устарел и у пользователя есть право на выполнение действия:
Главный модуль обрабатывает запрос и отвечает данными;
Вot Logic формирует ответ на основе данных. Ответ уходит пользователю;
Если токен доступа не устарел, но у пользователя нет права на выполнение действия:
Главный модуль отвечает 403 кодом;
Вot Logic формирует ответ: не достаточно прав для этого действия. Ответ уходит пользователю;
Если токен доступа устарел:
Главный модуль отвечает 401 кодом;
Вot Logic формирует запрос к модулю Авторизации и отправляет токен обновления.
Если токен обновления устарел или не существует:
Модуль Авторизации отвечает 401 кодом и удаляет у себя устаревший токен;
Вot Logic отправляет запрос Redis и просит удалить указанный ключ. В качестве ключа используется chat_id. Пользователь переходит в статус Неизвестный;
Bot Logic формирует ответ сообщающий, что пользователь не заголинен и предлагающий пользователю авторизоваться через: GitHub, Яндекс ID или через код; Ответ уходит пользователю.
Если токен обновления валидный:
Модуль Авторизации создаёт новую пару токен доступа + токен обновления и заменяет у себя старый токен обновления новым. Новую пару отправляет в качестве ответа;
Вot Logic отправляет запрос Redis и просит заменить токены на новые для указанного ключа. В качестве ключа используется chat_id;
Повторно пытаемся выполнить запрос пользователя (переходим в начало этого пункта);
Циклические запросы внутри модуля Telegram клиент (проверка входа)
Компонент Telegram Client обрабатывает не только запросы от пользователей но и периодически срабатывает по таймеру.

Сработал таймер компонента Telegram Client;
Telegram Client делает запрос компоненту Bot Logic (перед ним сидит компонент Nginx);
Nginx перенаправляет запрос одной из рабочих копий компонента Bot Logic;
Bot Logic обращается к Redis и просит у него всех пользователей находящихся в статусе Анонимный;
Для каждого Анонимного пользователя делаем запрос к модулю Авторизации отправляя токен входа для проверки;
Если модуль авторизации ответил: не опознанный токен или время действия токена закончилось:
Bot Logic делает запрос Redis, чтобы тот удалил ключ chat_id. Пользователь переходит в статус Неизвестный;
Если модуль авторизации ответил: в доступе отказано (пользователь нажал Нет во время входа):
Bot Logic делает запрос Redis, чтобы тот удалил ключ chat_id. Пользователь переходит в статус Неизвестный;
Bot Logic добавляет в массив/словарь ответов: chat_id и Статус входа: неудачная авторизация;
Если ответ от модуля Авторизации: доступ предоставлен (пользователь нажал Да во время входа), то:
Bot Logic проверяет, что в ответе от модуля авторизации присутствуют 2 JWT токена: токен доступа (Access Token) и токен обновления (Refresh Token);
Они присутствуют. Bot Logic меняет статус пользователя на Авторизованный и делает запрос Redis сохранить новый статус пользователя и оба JWT токена (токен входа больше не нужен). В качестве ключа используется chat_id;
Bot Logic добавляет в массив/словарь ответов: chat_id и Статус входа: успешная авторизация;
Bot Logic отправляет компоненту Telegram Client массив/словарь ответов;
Telegram Client отправляет сообщение каждому пользователю из полученного массива/словаря.
Циклические запросы внутри модуля Telegram клиент (проверка уведомлений)
Сработал таймер компонента Telegram Client;
Telegram Client делает запрос компоненту Bot Logic (перед ним сидит компонент Nginx);
Nginx перенаправляет запрос одной из рабочих копий компонента Bot Logic;
Bot Logic обращается к Redis и просит у него всех пользователей находящихся в статусе Авторизованный;
Для каждого Авторизованного пользователя делаем запрос к Главному модулю на URL /notification отправляя его JWT токен доступа:
Если для текущего пользователя есть уведомления, Bot Logic добавляет их в массив/словарь ответов: chat_id и массив уведомлений;
Bot Logic отправляет Главному модулю запрос на удаление уведомлений для текущего пользователя отправляя его JWT токен доступа;
Bot Logic отправляет компоненту Telegram Client массив/словарь ответов;
Telegram Client отправляет сообщение каждому пользователю из полученного массива/словаря.
